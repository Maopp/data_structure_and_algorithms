# 冒泡排序

- **原理**：比较两个相邻的元素，将值大的元素元素交换至右端。
- **思路**：一次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。
第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；
第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；
依次类推，每一趟比较次数-1；

## 实现方式：
N个数字要排序完成，总共进行N-1趟排序，第i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数
```
    for(int i = 1;i < arr.length;i++){
        for(int j = 1;j < arr.length-i;j++){
            // 交换位置
        }
    }
```

## 优点：
> 每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

## 时间复杂度：
    1.如果数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡
    排序最好的时间复杂度为O(n)。
    2.如果数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换
    记录位置。在这种情况下，比较和移动次数均达到最大值：
    ![冒泡排序最差时间复杂度](/src/images/algorithms/bubble_sort/冒泡排序最差时间复杂度.jpg)
    所以，冒泡排序的最坏时间复杂度为：O(n^2)
所以，冒泡排序总的平均时间复杂度为：O(n^2) 。