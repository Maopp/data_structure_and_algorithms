# 计数排序
> 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的
个数。然后根据数组C来将A中的元素排到正确的位置。**它只能对整数进行排序。**

> 对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。
所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。

- **原理**：计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序
要求输入的数据必须是有确定范围的整数。
- **思路**：
1.
    - 找出待排序的数组中最大和最小的元素；
    - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
    - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
    - 填充目标数组：将数组C的元素依次放到目标数组中，每放一个元素就将C(i)减去1。
关键算法：
```$xslt
    int tempIndex = 0;
    for (int i = 0;i < countArr.length;i++) {
        if (countArr[i] > 0) {
            for (int j = 0;j < countArr[i];j++) {
                arr[tempIndex++] = i;
            }
        }
    }
``` 
2.
    - 求出待排序数组的最大值max=6， 最小值min=1
    - 实例化辅助计数数组help，help用来记录每个元素之前出现的元素个数
    - 计算 arr 每个数字应该在排序后数组中应该处于的位置，此时 help = [1,1,4,5,6,7];
    - 根据 help 数组求得排序后的数组，此时 res = [1,3,3,4,5,6]

## 优点：
> 排序的速度快于任何比较排序算法

## 时间复杂度：
> 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小 值的差加上1），这使得计数排序对于
数据范围很大的数组，需要大量时间和内存。
T(n) = O(n+k)
