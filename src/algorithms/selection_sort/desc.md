# 选择排序

- **原理**：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，知道全部记录排序完毕。也就是：每一趟
在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有*简单选择排序*、*树型选择排序*和*堆排序*。
- **思路**：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arr[1]交换；
第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与arr[2]交换；
以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与arr[i]交换，直到全部排序完成。

## 优点：
- 因为每趟循环用到外循环当前值，所以可以只记录最小值索引，等内循环完成后再交换位置，节省数据交换开销。

## 时间复杂度：
- 简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有n个元素，则比较次数永远都是n(n - 1 + 1) / 2。
而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为：0。
当序列反序时，移动次数最多，为：3n(n - 1 + 1) / 2；优化后的移动次数为：n - 1。
所以，简单选择排序的时间复杂度为：O(n^2)